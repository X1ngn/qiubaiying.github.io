---
layout:     post
title:      学习CodeQL（更新中）
subtitle:   还有数据流的知识点没有补充
date:       2020-11-08
author:     X1ng
header-img: codeql.jpg
catalog: true
tags:

    - 学习笔记
    - CodeQL

---

## 环境配置

环境就配了大半天，，菜得连教程都看不懂

1. [安装VSCode](https://code.visualstudio.com/download)，mac下只要解压压缩包把app文件移到应用程序文件夹里就可以了

2. 然后安装VSCode上CodeQL插件，在extensions栏下搜索"codeql"就能找到

3. 下载CodeQL分析程序

    `https://github.com/github/codeql-cli-binaries/releases/latest/download/codeql.zip`

    解压后的目录

    ![](https://tva1.sinaimg.cn/large/0081Kckwly1gkjwbtegekj30yk0j4whi.jpg)

4. 配置拓展设置

    ![](https://tva1.sinaimg.cn/large/0081Kckwly1gkhvrd9l79j30yy0ss7ds.jpg)

    ![](https://tva1.sinaimg.cn/large/0081Kckwly1gkhvrec0gkj31sv0ld0yd.jpg)

    将`Executable Path`设置为CodeQL分析程序文件夹中的codeql可执行程序，mac下就是名为codeql的文件

5. 下载入门工作环境

    ```
    git clone https://github.com/github/vscode-codeql-starter.git
    ```

6. 下载相关库文件，可以根据库文件来编写QL脚本

    ```
    git clone https://github.com/github/codeql.git
    ```

    

## 基础知识

通过tutorial库中的例子学习使用codeql

### 数据类型

QL中的基本数据类型有

字符串`string`

整型`int`

浮点型`float`

日期型`data`：由整型组成，形如`start = 01/10/2019`

布尔型`boolean`



### 语法

听说语法类似SQL，，但是没有学过SQL没什么感觉or2

```SQL
import javascript
from Comment c	
/*定义一个Comment类型变量c，类似于定义Comment类的对象*/
where c.getText().regexpMatch("(?si).*\\bTODO\\b.*")	
/*对c这个对象的成员函数调用，按从左到右的顺序调用"."后面的成员函数来进行筛选*/
select c
/*选出这个符合条件的变量*/
```

这段代码定义了注释类型的变量c，然后查找满足带有"TODO"子字符串条件的注释，再用`select`语句选取出来



### 谓词

谓词描述的是给定参数与元组集合的关系，名称应该以小写字母开头

没有返回值的谓词类型定义为`predicate`，有返回值的谓词定义为返回值类型

对于没有返回结果的谓词，如果一个值满足谓词主体中的逻辑属性，那么谓词对这个值成立

例如

```sql
predicate hasCapital(string country, string capital) {
  country = "Belgium" and capital = "Brussels"
  or
  country = "Germany" and capital = "Berlin"
  or
  country = "France" and capital = "Paris"
}
```

当作为参数的country和capital满足三种情况中任意一种时，谓词hasCapital(country, capital)成立

谓词hasCapital面对的是一个两元元组集合，元数为2

谓词中的所有元组都具有相同数量的元素。谓词的元数就是各个元组的元素数量，但不包括result变量

result变量是对于有返回值的谓词而言的

例如

```sql
int getSuccessor(int i) {
  result = i + 1 and
  i in [1 .. 9]
}
```

如果i是小于10的正整数，那么谓词getSuccessor(i)的返回结果就是i+1

返回结果result不仅可以用作谓词的参数 ，也可以用来表示与其他变量之间的关系

可以让谓词的每个参数值都带有一个返回结果（或者一个返回结果也不带）

例如

```sql
string getANeighbor(string country) {
  country = "France" and result = "Belgium"
  or
  country = "France" and result = "Germany"
  or
  country = "Germany" and result = "Austria"
  or
  country = "Germany" and result = "Belgium"
}
```

调用getANeighbor("Germany") 将返回两个结果："Austria"和"Belgium"

调用getANeighbor("Belgium") 不会返回任何结果

但是如果加上一句递归调用

例如

```sql
string getANeighbor(string country) {
  country = "France" and result = "Belgium"
  or
  country = "France" and result = "Germany"
  or
  country = "Germany" and result = "Austria"
  or
  country = "Germany" and result = "Belgium"
  or
  country = getANeighbor(result)
}
```

调用getANeighbor("Belgium")会返回"France"和"Germany"。

在调用谓词的时候，定义在类中的成员谓词是跟在变量后面的（类似于成员函数），而一般的谓词是将变量作为参数使用的

需要注意的是，抽象谓词或外部谓词是没有主体部分的，要定义这样的谓词，需要用分号";"来结束谓词的定义。



### 逻辑连接词

可以用 `and`和`or`连接两个表达式

在表达式前加上`not`表示取反

例如

```sql
where t.getAge() > 30
  and (t.getHairColor() = "brown" or t.getHairColor() = "black")
  and not t.getLocation() = "north"
```

`exist`表示存在量词，`forall`表示全称量词

例如

```sql
from Person t
where exists(string c | t.getHairColor() = c)
select t
```

上面的exists引入了一个字符串类型的临时变量 c，变量c的定义以及操作之间用"|"分割，表示仅在至少有一个字符串c满足条件 `t.getHairColor() = c`时，也就是有头发（有头发才能取到头发的颜色）时，这个where子句才成立



### 聚合函数

聚合函数就是对多个数据块进程处理，并返回单个值的函数

常见的聚合函数为count、max、 min、avg和sum

例如

```sql
from Person t
where t.getAge() = max(int i | exists(Person p | p.getAge() = i) | i)
select t
```

在聚合函数中用两个"|"分隔 变量的定义、逻辑公式和进行计算的变量

上面这句代码表示搜索出年龄最大的人

有序聚合是QL的一种特性，通过order by对表达式进行排序

```sql
select max(Person p | | p order by p.getAge())
```

这句代码与上面的聚合一样意思，对于要考察的人没有其他方面的限制，因此，逻辑公式子句为空，如果有多个人具有相同的最大年龄，那么该查询将列出所有这些人

对于有逻辑公式子句的情况

例如

```sql
sum(Person p | p.getHairColor() = "brown" | p.getAge())
```

上面的代码的作用是计算头发为棕色的村民的年龄总和



### 类

>对于QL语言来说，可以用类来表示一个逻辑属性：当一个值满足该属性时，它就是类的成员。这意味着一个值可以属于多个类，这其实不难理解，举例来说，3既属于“整数”类，也属于“奇数”类，同时属于“质数”类，等等

可以自定义一个Southerner类来找出住在村南的居民，具体代码如下所示

```sql
predicate southern(Person p) {
    p.getLocation() = "south"
}

class Southerner extends Person {
    Southerner() { southern(this) }
}

from Southerner s
select s
```

`southern(this)`定义了这个类所表示的逻辑属性，这个谓词是这个类的特征谓词，类似于面向对象中的构造函数，但它，不创造任何对象，只是在一个变量满足条件时让其属于该类

而`this`在此处是指一个Person类的对象，如果this满足`southern(this)`这一限制条件，那么this代表的村民就属于Southerner类，也就是居住在村南的村民

这里根据现有的Person类（超集）来定义新的Southerner类（子集），在这个例子中，Southerner（住在村南的村民）类继承自Person（村民）类，换句话说，Southerner是Person的一个子集



对于继承了父类成员谓词的子类，可以通过重新定义成员谓词来覆盖原来的成员谓词

例如

对于原来的情况，所有Person可以去村里任何地方

```sql
from Person p
where p.isAllowedIn("north")
select p
```

因为`p.isAllowedIn("north")`搜索可以去北方的人，而这对所有人都成立，所以这段代码会查找到所有的村民

而如果限制孩子只能在所住的地方活动的话

```sql
class Child extends Person {
    /* the characteristic predicate */
    Child() { this.getAge() < 10 }
 
    /* a member predicate */
    override predicate isAllowedIn(string region) {
        region = this.getLocation()
    }
}
```

覆盖了Person类中的成员谓词isAllowedIn，对于孩子来说只有在自己所住的地方是region变量表示的地方时才成立

当我们再将谓词isAllowedIn(string region)应用于表示村民的变量上的时候，如果变量的类型为Child，也就是说这个变量表示的村民是一个孩子，那么该谓词将会使用Child类中的新定义，否则使用原来的定义



### DEMO

自己写一个C++demo，用codeql查找

test1.cpp:

```cpp
#include <iostream>

using namespace std;

int main()
{
    int a, b;
    cin >> a >> b;
    if(a > b)
        cout << "a>b\n";
    if(b > a)
    {}
    return 0;
}
```

在命令行移动到test1.cpp保存的目录下，运行

```shell
~/ql/codeql/codeql database create --language=cpp ./cpp-database --command="g++ -o test1 test1.cpp"
```

用之前下载的CodeQL程序中codeql可执行文件来创建database（command不指定则会使用自带的默认编译）

打开VSCode，`File`->`Open Workspace` 打开入门工作环境目录中的`vscode-codeql-starter.code-workspace`文件

在QL插件窗口选择从目录加载database

![](https://tva1.sinaimg.cn/large/0081Kckwly1gkjwizjbwuj31430u0dmh.jpg)

选择刚才创建的`cpp-database`目录加载database

将工作环境中cpp目录下的`example.ql`文件内容改为

```sql
import cpp

from IfStmt ifstmt, BlockStmt block
/*if变量声明，语句块的变量声明*/
where ifstmt.getThen() = block and block.getNumStmt() = 0 
/*ifstmt.getThen() = block关联两个变量,该块必须是该if语句的分支*/
/*block.getNumStmt() = 0 声明该块必须为空（即，它不包含任何语句）*/
select ifstmt, "This 'if' statement is redundant."
```

![](https://tva1.sinaimg.cn/large/0081Kckwgy1gkjwqs40f9j31440u00xx.jpg)

`shift+command+p`呼出命令窗口，输入`CodeQL:Run Query`进行查找，找到空if语句

没有看懂如何在修改项目后更新database，目前只好`~/ql/codeql/codeql database cleanup cpp-database`删除数据库后再重新创建



### 迭代器失效

迭代器是一种面向对象的广义指针，用于指向容器中或流中的对象，能够在不了解容器内部原理的情况下遍历容器，可以看做是一种指向数据的指针。

在容器通过迭代器进行插入或删除操作的时候，可能会导致**迭代器指向不应该指向的内存或未知的内存**，造成迭代器失效

只要进行删除操作(erase)的时候，指向删除点的迭代器就失效了

下面是几种容器类型的迭代器失效例子

#### vector迭代器

vector的底层实现是一种动态数组，是连续的内存空间

- 当进行插入操作后（插入点之后的所有元素往后移动），原先end操作返回的迭代器会失效

    ```cpp
    #include <iostream>
    #include <vector>
    
    using namespace std;
    
    int main()
    {
        vector<int> v;
        v.push_back(0);
    
        vector<int>::iterator it;
        it = v.end();
    
        v.push_back(1);
        cout << *it;
        
        return 0;
    }
    
    ```

    最后输出0，而不是预期的1，原先end操作赋值的迭代器已经失效了

- 当进行插入操作后，需要进行扩容时（重新分配一个动态数组，大小为`size += size/2`），指向原来地址的迭代器全部失效

    ```cpp
    #include <iostream>
    #include <vector>
    
    using namespace std;
    
    int main()
    {
        vector<int> v;
        for(int i = 1; i < 5; i++)
            v.push_back(i);
    
        vector<int>::iterator it;
        it = v.begin();
        cout << *it << '\n';
    
        for(int i = 5; i < 10; i++)
            v.push_back(i);
        cout << *it;
    
        return 0;
    }
    
    ```

    输出1和0，原先赋值的迭代器已经失效了

- 当进行删除操作后（删除点之后的所有元素往前移动），指向删除点后面的元素的迭代器也将全部失效

    

#### list迭代器

list的底层实现是双向链表，每个元素都是放在一块内存中,内存空间可以是不连续的

所以list迭代器只有在删除操作的时候，指向删除点的迭代器失效

#### deque迭代器

deque（双端队列）的底层实现是一段一段等长的连续空间，维护一个索引数组存放地址

![](https://tva1.sinaimg.cn/large/0081Kckwly1gkk5epyozhj30be09cgm5.jpg)

- 在头尾插入元素时，该段连续空间满时（需要重新分配内存和索引数组），迭代器失效，但指针和引用有效
- 在其他位置插入元素时（其他元素移动），原先的迭代器、指针和引用都失效
- 在其他位置删除元素时（其他元素移动），原先的迭代器、指针和引用都失效

#### set和map迭代器

set和map的底层实现都是红黑树，与list一样只有在删除操作的时候，指向删除点的迭代器失效



参考

https://paper.seebug.org/1078/

https://xz.aliyun.com/t/7657

https://www.4hou.com/posts/wRAw